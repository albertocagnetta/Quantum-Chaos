int n=40 ; //number of modes
int nev=10; //number of e i g env a l u e s to be c a l c u l a t e d

string fnm = "bolza_surface_30n_100nev.txt" ; //file name for saving
real r = 0.4550898605622276; // radius of circle
real c = 1.09868411346781; // centre of circle on x-axis


real sigma=0.1 ; // value of the shift

// 86.1472
// 199.353
// 894.963
// 905


border G1 (t=5*pi/4,3*pi/4) { x=c+r*cos(t) ; y=r*sin(t); label=1;};

border G2 ( t=5*pi/4,3*pi/4){x=cos(pi/4)*(c+r*cos(t))-sin(pi/4)*r*sin(t); y=sin(pi/4)*(c+r*cos(t))+cos(pi/4)*r*sin(t);label=2;};

border G3 ( t=5*pi/4,3*pi/4){x=cos(pi/2)*(c+r*cos(t))-sin(pi/2)*r*sin(t); y=sin(pi/2)*(c+r*cos(t))+cos(pi/2)*r*sin(t); label=3; };

border G4 (t=5*pi/4,3*pi/4){x=cos(3*pi/4)*(c+r*cos(t))-sin(3*pi/4)*r*sin(t); y=sin(3*pi/4)*(c+r*cos(t))+cos(3*pi/4)*r*sin(t); label=4; };

border G5 (t=5*pi/4,3*pi/4){x=cos(pi)*(c+r*cos(t))-sin(pi)*r*sin(t); y=sin(pi)*(c+r*cos(t))+cos(pi)*r*sin(t); label=5; };

border G6 (t=5*pi/4,3*pi/4){x=cos(5*pi/4)*(c+r*cos(t))-sin(5*pi/4)*r*sin(t); y=sin(5*pi/4)*(c+r*cos(t))+cos(5*pi/4)*r*sin(t); label=6; };

border G7 (t=5*pi/4,3*pi/4){x=cos(6*pi/4)*(c+r*cos(t))-sin(6*pi/4)*r*sin(t); y=sin(6*pi/4)*(c+r*cos(t))+cos(6*pi/4)*r*sin(t);  label=7;};

border G8 (t=5*pi/4,3*pi/4){x=cos(7*pi/4)*(c+r*cos(t))-sin(7*pi/4)*r*sin(t); y=sin(7*pi/4)*(c+r*cos(t))+cos(7*pi/4)*r*sin(t);  label=8;};

plot (G1(n)+G2(n)+G3(n)+G4(n)+G5(n)+G6(n)+G7(n)+G8(n));

mesh Th=buildmesh(G1(n)+G2(n)+G3(n)+G4(n)+G5(n)+G6(n)+G7(n)+G8(n),fixeborder=true);

plot (Th,wait=true,fill=true);


//Adapting the mesh messes up the periodic boundary conditions
func metric = 4/(1-x^2-y^2)^2;
//mesh ATh = adaptmesh(Th,metric);
//Th = adaptmesh(Th,metric);

plot (Th,wait=true,fill=true);




fespace Vh(Th,P2,periodic=[[1,y],[5,y],[3,x],[7,x],[2,y-x],[6,y-x],[4,y+x],[8,y+x]]);

//glues opposite sides such that orientation is preserved
Vh u1,u2;




varf op(u1,u2)=int2d(Th)(dx(u1)*dx(u2)+dy(u1)*dy(u2)-sigma*(u1*u2)*metric);
varf b([u1],[u2])=int2d(Th)((u1*u2)*metric);

matrix OP = op(Vh,Vh,solver=LU,factorize=1);
matrix B = b(Vh,Vh,solver=CG,eps=1e-20);

real[int] ev(nev);
Vh[int] eV(nev);

int k=EigenValue(OP,B,sym=true, sigma=sigma, value=ev, vector=eV, tol=1e-12, maxit=0, ncv=0);

for(int i=0; i<k;i++){
	u1=eV[i];
	real gg = int2d(Th)(dx(u1)*dx(u1)+dy(u1)*dy(u1));
	real mm= int2d(Th)(u1*u1);
	
	ofstream Eva(fnm,append);
	Eva << ev[i] << "\n";
	cout << "lambda[" << i << "] = " << ev[i] << ", err= " << int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - ((ev[i])*u1*u1)*4/(1-x^2-y^2)^2) << endl;
    plot(eV[i], cmm="Eigen Vector "+i+" value ="+ev[i], wait=true, value=true, fill=true);  //,hsv=colorhsv);
	//cout<<"----"<<i<<""<<ev[i]<<"err="<<dx(u1)*dx(u1)+dy(u1)*dy(u1)-(ev[i])*u1*u1<< "---" << endl; plot(eV[i], cmm="EigenVector"+i+"valeur="+ev[i],wait=1,value=1);
	//uncomment the above two lines to display level sets for each eigenfunction
}