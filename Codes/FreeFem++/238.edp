int n=40 ; //number of modes
int nev=10; //number of e i g env a l u e s to be c a l c u l a t e d

string fnm = "238tri_50n_100nev_nnn.txt" ; //file name for saving
real r = 0.4550898605622276; // radius of circle
real c = 1.09868411346781; // centre of circle on x-axis


real sigma=0.001 ; // value of the shift



border G1 (t=0 ,0.4056163087774724) { x=t ; y=0;};

border G2 ( t= 0.33681578765748216, 0){x=t; y=t*tan(pi/8);label=2;};

border G3 ( t=0.4056163087774724,0.33681578765748216){x=t; y=0.5946036542842016-sqrt((1.189207445439991^2)-(t-1.435500206409523)^2); label=3; };

plot (G1(n)+G2(n)+G3(n));

mesh Th=buildmesh(G1(n)+G2(n)+G3(n));




//Adapting the mesh messes up the periodic boundary conditions
func metric = 4/(1-x^2-y^2)^2;
//mesh ATh = adaptmesh(Th,metric);
//Th = adaptmesh(Th,metric);

plot (Th,wait=true,fill=true);




fespace Vh(Th,P2);

//glues opposite sides such that orientation is preserved
Vh u1,u2;




varf op(u1,u2)=int2d(Th)(dx(u1)*dx(u2)+dy(u1)*dy(u2)-sigma*(u1*u2)*metric)+on(G1,u1=0)+on(G2,u1=0)+on(G3,u1=0);
varf b([u1],[u2])=int2d(Th)((u1*u2)*metric);

matrix OP = op(Vh,Vh,solver=LU,factorize=1);
matrix B = b(Vh,Vh,solver=CG,eps=1e-20);

real[int] ev(nev);
Vh[int] eV(nev);

int k=EigenValue(OP,B,sym=true, sigma=sigma, value=ev, vector=eV, tol=1e-12, maxit=0, ncv=0);

for(int i=0; i<k;i++){
	u1=eV[i];
	real gg = int2d(Th)(dx(u1)*dx(u1)+dy(u1)*dy(u1));
	real mm= int2d(Th)(u1*u1);
	
	ofstream Eva(fnm,append);
	Eva << ev[i] << "\n";
	cout << "lambda[" << i << "] = " << ev[i] << ", err= " << int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - ((ev[i])*u1*u1)*4/(1-x^2-y^2)^2) << endl;
    plot(eV[i], cmm="Eigen Vector "+i+" value ="+ev[i], wait=true, value=true, fill=true);  //,hsv=colorhsv);
	//cout<<"----"<<i<<""<<ev[i]<<"err="<<dx(u1)*dx(u1)+dy(u1)*dy(u1)-(ev[i])*u1*u1<< "---" << endl; plot(eV[i], cmm="EigenVector"+i+"valeur="+ev[i],wait=1,value=1);
	//uncomment the above two lines to display level sets for each eigenfunction
}